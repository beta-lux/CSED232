\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{fontspec}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stackengine}
\usepackage{minted}
\usepackage{mathtools}
\usepackage{graphicx,wrapfig,tikz}
\usepackage{physics}
\setlength\intextsep{0pt}
\usetikzlibrary{calc,hobby}
\usepackage{pgfplots}
\usepackage{xcolor}
\usepackage{xargs}
\usepackage{kotex}
\usepackage{mathrsfs} %fourier transform
\usetikzlibrary{external}
\usetikzlibrary{arrows}
\usepackage{setspace}
\usetikzlibrary{arrows}
\usepackage{tabstackengine}
\usepackage{enumitem}
\usepackage{longtable}
\usepackage{listings}
\setlist[enumerate]{itemsep=0mm}
\setlist[enumerate]{label={\arabic*.}}

\definecolor{beta-gray}{rgb}{0.9,0.9,0.9}

\newcommand{\lt}{\;\,}
\newcommand{\ft}{\quad\!}
\newcommand{\ot}{\quad\;}
\newcommand{\dt}{\;\,\;\,}
\newcommand{\plm}[1]{\setcounter{enumi}{#1 - 1}}
\newcommand{\nd}{\quad \text{and} \quad}
\newcommand{\inline}[1]{%
    \colorbox{beta-gray}{\lstinline[language=C++]{#1}}%
}

\newenvironment{code}[5]{
    {
        \usemintedstyle{xcode}
        \fontspec{Menlo}
        \begin{spacing}{1.0}
            \let\itshape\relax
            \inputminted[frame=single, firstline=#3, lastline=#4]{#1}{#2}
        \end{spacing}
        \vspace{#5}
    }

}

\newenvironment{answer}{
    {
        \\\textbf{Answer.}\\
    }
    {}
}

\usepackage[margin=1in]{geometry}

\begin{document}
    \author{권민재, 20190084}
    \title{\textbf{CSED232: Object-Oriented Programming Final Exam}}
    \date{June 27, 2020}
    \maketitle

    \setstretch{1.5}

    \begin{enumerate}[itemsep=30pt]
        \item 다음 개념들이 각각 무엇을 뜻하는지 한두줄 내외로 간략히 기술하시오.(각 4점, 총 28점)
        \begin{enumerate}[label={\Alph*.}, itemsep=15pt]
            \item Pure virtual function
            \begin{answer}
                Pure virtual function은, 보통 이것이 선언된 클래스에서 함수의 내용이 구현되지 않고, derived 클래스에서 내용을 구현해야 하는 virtual function이다.
            \end{answer}
            \item Function overloading
            \begin{answer}
                Function overloading은 함수의 이름은 같지만, 매개변수의 종류나 개수가 다른 여러 함수를 만들 수 있는 기능을 일컫는다.
                이 함수가 불릴 때, 주어진 매개변수에 대해 가장 적절한 함수가 실행되며, 적절한 함수가 하나도 없을 경우에는 실행되지 않는다.
            \end{answer}
            \item Function overriding
            \begin{answer}
                Function overriding은
            \end{answer}
            \item Dynamic binding
            \begin{answer}\end{answer}
            \item Abstract base class
            \begin{answer}\end{answer}
            \item Generic programming
            \begin{answer}\end{answer}
            \item Event-driven programming
            \begin{answer}\end{answer}
        \end{enumerate}
        \item C++ Standard Template Library 의 algorithm 들은 iterator 를 사용하도록 설계되어 있다. iterator 를 사용하는 것의 장점이 무엇인지에 대해 간략하고 명확하게 기술하시오. (4 점)\\
        \begin{answer}
            asdf
            sadf
        \end{answer}
        \item Has-a relationship 을 구현하기 위한 두 가지 대표적인 방법으로 containment 와 private inheritance 가 있다. Has-a relationship 이 무엇인지 기술하고, 또한 containment 와 private inheritance 의 장단점을 비교하시오. (8 점)
        \item Private inheritance 와 protected inheritance 의 차이점을 자세히 기술하시오. (4 점)
        \item 다음 코드를 실행시켰을 때 출력되는 내용은 무엇인가? 그리고 왜 그런 출력이 나오는가? 다음 코드를 실행시켰을 때 출력될 내용을 적고, 그 이유를 간단히 기술하시오. (8 점)
        \item 다음은 재귀 호출을 이용하여 factorial 을 계산하는 코드이다. \code{cpp}{06-plm.cpp}{}{}{15pt} 이를 template 을 이용하여 아래와 같이 바꿀 수 있다. 이렇게 template 을 이용하는 방법의 장점은 실제 factorial 계산을 런타임에 하는 대신 컴파일 타임에 할 수 있어서 프로그램의 실행시간을 단축시킬 수 있다는 장점이 있다. 이 때 빈칸에 필요한 코드를 template specialization 을 이용하여 작성하시오. (8 점)
              \code{cpp}{06.cpp}{2}{}{15pt}
        \item 아래의 코드는 C++11 표준 라이브러리에서 제공하는 스마트 포인터 중 하나인 unique\_ptr 을 간략화하여 구현한 클래스이다. 아래의 코드를 완성하기 위한 move constructor 와 move assignment operator 의 코드를 작성하시오. (8 점)
              \code{cpp}{07.cpp}{}{}{15pt}
        \item 다음 코드에는 런타임에 발생할 수 있는 한가지 문제점이 존재한다. 이 문제점이 무엇인가? 그리고 이 문제점을 해결하기 위해서는 코드를 어떻게 수정해야 하는가? SomeClass 와 SomeException 클래스는 모두 적절히 정의되어 있다고 가정한다. (8 점)
        \item 다음 코드에서 C-style 의 type cast 연산자들을 각각 그에 대응하는 static\_cast, const\_cast, reinterpret\_cast로 변경한 코드를 작성하시오. (8 점)
              \code{cpp}{09.cpp}{}{}{15pt}
        \item 다음 코드의 Vec2D 는 2 차원 벡터를 다루기 위한 template class 이다. 아래 코드의 main 함수에서는 Vec2D<int>와 Vec2D<float>의 서로 다른 데이터 타입의 Vec2D 오브젝트 사이의 덧셈 연산을 수행하는 것을 보여준다. 이 덧셈 연산을 구현하기 위한 operator+ 의 오버로딩이 파란색으로 표시되어 있다. 여기서 이 코드에 필요한 적절한 prototype 을 빈칸에 추가하시오. 오버로딩된 operator+는 template function 으로 되어 있으며, Vec2D<int>와 Vec2D<float>, 또는 Vec2D<double>과 Vec2D<long>과 같은 임의의 서로 다른 데이터 타입의 Vec2D 오브젝트 간의 덧셈 연산을 지원한다. 또한 Vec2D<int> 오브젝트와 Vec2D<float> 오브젝트의 덧셈 연산 시 결과로 나와야 되는 타입 (Vec2D<float>) 이 자동으로 결정된다. (4 점)
              \code{cpp}{10.cpp}{2}{}{15pt}
        \item 다음 코드의 지역 변수인 data 는 integer 값들을 담고 있는 vector 이다. 아래 코드에서 파란 색으로 표시된 코드는 이 data 의 각각의 값들의 조사하여 upper\_bound 보다 큰 값들은 upper\_bound 로 값을 변경하고, lower\_bound 보다 작은 값들은 lower\_bound 로 변경하는 작업을 수행한다. 아래 파란색으로 표시된 코드와 동일한 작업을 수행하는 3 가지의 코드를 작성하시오. 각각의 코드는 아래에 A,B,C 로 표시된 내용을 각각 활용하여 작성되어야 한다. (12 점)
              \begin{enumerate}[label={\Alph*.}, itemsep=15pt]
                  \item for-loop 와 iterator 이용 \code{cpp}{11-A.cpp}{}{}{15pt}
                  \item std::transform 함수와 lambda 함수 이용 \code{cpp}{11-B.cpp}{}{}{15pt}
                  \item std::for\_each 함수와 lambda 함수 이용 \code{cpp}{11-C.cpp}{}{}{15pt}
              \end{enumerate}
    \end{enumerate}
\end{document}